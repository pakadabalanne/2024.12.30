.........RPC...................................................................................................

>>>>>>>Calculator>>>>>.....

.....main.......

struct cal{

int a;
int b;

};

program CalProg{
version CalVers{
 int add(cal)=1;
 int sub(cal)=2;
 int mul(cal)=3;
 int div(cal)=4;


}=15;
}=17;

......server......

 /*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculator.h"

int *
add_15_svc(cal *argp, struct svc_req *rqstp)
{
	static int  result;
	
	printf("Addition of (%d,%d) is called\n",argp->a,argp->b);
	result=argp->a + argp->b;
	return &result;
}

int *
sub_15_svc(cal *argp, struct svc_req *rqstp)
{
	static int  result;

	printf("Subtraction of (%d,%d) is called\n",argp->a,argp->b);
	result=argp->a - argp->b;

	return &result;
}

int *
mul_15_svc(cal *argp, struct svc_req *rqstp)
{
	static int  result;

	printf("Muultiplication of (%d,%d) is called\n",argp->a,argp->b);
	result=argp->a * argp->b;
	return &result;
}

int *
div_15_svc(cal *argp, struct svc_req *rqstp)
{
	static int  result;

	printf("Division of (%d,%d) is called\n",argp->a,argp->b);
	result=argp->a / argp->b;

	return &result;
}


..........client.........

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculator.h"


void
calprog_15(char *host)
{
	CLIENT *clnt;
	int  *result_1;
	cal  add_15_arg;
	int  *result_2;
	cal  sub_15_arg;
	int  *result_3;
	cal  mul_15_arg;
	int  *result_4;
	cal  div_15_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, CalProg, CalVers, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
	
	printf("Enter the first number:");
	scanf("%d",&(add_15_arg.a));
	
	printf("Enter the second number:");
	scanf("%d",&(add_15_arg.b));
	
	
#endif	/* DEBUG */

	result_1 = add_15(&add_15_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	else{
	printf("Addition is:%d\n",*result_1);
	}  
	
	
	
	printf("Enter the first number:");
	scanf("%d",&(sub_15_arg.a));
	
	printf("Enter the second number:");
	scanf("%d",&(sub_15_arg.b));
	
	
	result_2 = sub_15(&sub_15_arg, clnt);
	if (result_2 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	else{
	printf("Subtration is:%d\n",*result_2);
	}
	
	
	
	printf("Enter the first number:");
	scanf("%d",&(mul_15_arg.a));
	
	printf("Enter the second number:");
	scanf("%d",&(mul_15_arg.b));
	
	result_3 = mul_15(&mul_15_arg, clnt);
	if (result_3 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	else{
	printf("Multiplication is:%d\n",*result_3);
	}
	
	
	
	printf("Enter the first number:");
	scanf("%d",&(div_15_arg.a));
	
	printf("Enter the second number:");
	scanf("%d",&(div_15_arg.b));
	
	result_4 = div_15(&div_15_arg, clnt);
	if (result_4 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	else{
	printf("Division is:%d\n",*result_4);
	}
	
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	calprog_15 (host);
exit (0);
}
....................................................................................................
.>>>>>>>>>>>>>RPC Enter world find vowel and characters.........

>>>>>>>Main>>>>>>>>>

program VOWEL_CONSONANT_PROG {
    version VOWEL_CONSONANT_VERS {
        struct VowelConsonantCount {
            int vowels;
            int consonants;
        } count_vowels_consonants(string) = 1;
    } = 1;
} = 0x20000001;


<<<<<<server>>>>>>>>>>

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "vowel_consonant.h" // Generated by rpcgen

VowelConsonantCount *
count_vowels_consonants_1_svc(char **input, struct svc_req *req) {
    static VowelConsonantCount result;
    result.vowels = 0;
    result.consonants = 0;

    char *str = *input;

    for (int i = 0; str[i] != '\0'; i++) {
        char ch = tolower(str[i]);
        if (ch >= 'a' && ch <= 'z') {
            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {
                result.vowels++;
            } else {
                result.consonants++;
            }
        }
    }

    return &result;
}


>>>>>>>>client>>>>>>>>>>

#include <stdio.h>
#include <rpc/rpc.h>
#include "vowel_consonant.h" // Generated by rpcgen

int main(int argc, char **argv) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <server_host> <string>\n", argv[0]);
        return 1;
    }

    char *server_host = argv[1];
    char *input_string = argv[2];
    CLIENT *client;
    VowelConsonantCount *result;

    client = clnt_create(server_host, VOWEL_CONSONANT_PROG, VOWEL_CONSONANT_VERS, "tcp");
    if (client == NULL) {
        clnt_pcreateerror(server_host);
        return 1;
    }

    result = count_vowels_consonants_1(&input_string, client);
    if (result == NULL) {
        clnt_perror(client, "Call failed");
        return 1;
    }

    printf("Vowels: %d\n", result->vowels);
    printf("Consonants: %d\n", result->consonants);

    clnt_destroy(client);
    return 0;
}
...........................................................................................

>>>>>>>>>>>>>>>>Fabanocchi-RPC>>>>>>>>>>>>>>>>>>>>>>>>  

.......main..........

struct Fib{

int n;

};

program FIB_PROG{

version FIB_VERS{
int fibonacci(Fib)=1;

}=1;



}=123456;


..........server...............

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "fib.h"

int *
fibonacci_1_svc(Fib *argp, struct svc_req *rqstp)
{
	static int  result;

	int a=0;
	int b=1;
	int c;
	
 for(int i=0;i<argp->n;i++){
 
 	if(i<=1)
	 c=i;
 
 	else{
 		c=a+b;
 		a=b;
 		b=c;
 
 }
 	printf("%d\n",c);
 	result = c;
 
 }

	return &result;
}


...............client.......

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "fib.h"


void
fib_prog_1(char *host)
{
	CLIENT *clnt;
	int  *result_1;
	Fib  fibonacci_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, FIB_PROG, FIB_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	printf("Enter the number of terms you need in Fibonacci series:");
	scanf("%d",&(fibonacci_1_arg.n));

	result_1 = fibonacci_1(&fibonacci_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	else{
	printf("The series will be shown in the server");
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	fib_prog_1 (host);
exit (0);
}
...............................................................................................
>>>>>>>>>>>>Grade in run server>>>>>>>>>>>>>>>>>> 

......main.........

struct grade{

int m;

};

program MarkProg{
version MarkVers{

int grades(grade)=1;

}=2;
}=3;

.......server..........

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "grade.h"

int *
grades_2_svc(grade *argp, struct svc_req *rqstp)
{
	static int  result;

	if( argp->m <= 100 && 80 < argp->m)
	printf("Grade A\n");
	
	else if(argp->m <= 80 && 60 < argp->m)
	printf("Grade B\n");
	
	else if(argp->m <= 60 && 40 < argp->m)
	printf("Grade C\n");
	
	else 
	printf("Invalid\n");

	return &result;
}

.......client.........

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "grade.h"


void
markprog_2(char *host)
{
	CLIENT *clnt;
	int  *result_1;
	grade  grades_2_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, MarkProg, MarkVers, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
	
	printf("Enter the mark:");
	scanf("%d",&(grades_2_arg.m));
	
	
	
#endif	/* DEBUG */

	result_1 = grades_2(&grades_2_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	else{
	printf("The output will be viewed in the server\n");
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	markprog_2 (host);
exit (0);
}
....................................................................................

>>>>>>>>>>>>>>Reverse number>>>>>>>>>>>>>>>>

while (argp->nums !=0){
	   y=y*10;
	   y= y+(argp->nums % 10);
	   argp->nums /=10;
	   result = y;
	}


>>>>>>>>>factorial number>>>>>>>>>>>>>>>>>

nu_2_svc(fact *argp, struct svc_req *rqstp)
{
	static int  result,x,n;
	
	int i;
	n = argp->a;
	x=1;
   
      for(i=n ; i>0 ; i--){
       x = x*i;
      }
   
    result = x;

	return &result;
}

..............................................................................
<<<<<<<<<<<<<<RMI>>>>>>>>>>>>>

...........fibonaci.RMI..........

...........interface.........

import java.rmi.*;

public interface Fibonacci extends Remote {
    int[] calculateFibonacci(int number) throws RemoteException;
}
...........

........implement.......

import java.rmi.*;
import java.rmi.server.*;

public class FibonacciImpl extends UnicastRemoteObject implements Fibonacci {

    protected FibonacciImpl() throws RemoteException {
        super();
    }
    @Override
    public int[] calculateFibonacci(int number) throws RemoteException {
        if (number < 0) {
            throw new IllegalArgumentException("Number must be non-negative.");
        }
        int[] fibSequence = new int[number + 1];
        
        if (number >= 0) fibSequence[0] = 0;
        if (number >= 1) fibSequence[1] = 1;

        for (int i = 2; i <= number; i++) {
            fibSequence[i] = fibSequence[i - 1] + fibSequence[i - 2];
        }

        return fibSequence;
    }
}

.........

........server.....

import java.rmi.*;
import java.rmi.registry.*;

public class FibonacciServer {
    public static void main(String[] args) {
        try {

            FibonacciImpl fibonacci = new FibonacciImpl();
            Naming.rebind("ABC", fibonacci);
            System.out.println("RMI Server is running...");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


.......

......client..........

import java.rmi.Naming;

public class FibonacciClient {
    public static void main(String[] args) {
        try {
           
            Fibonacci fibonacci = (Fibonacci) Naming.lookup("ABC");  
            int number = 4; 
            int[] result = fibonacci.calculateFibonacci(number);
            System.out.print("Fibonacci sequence up to F(" + number + "): ");
            for (int i = 0; i <= number; i++) {
                System.out.print(result[i] + " ");
            }
            System.out.println();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

............................

.........3 number sum not user input............


......interface.............


import java.rmi.*;

public interface name_int extends Remote{

public int add(int x,int y,int z) throws RemoteException;

}


......implementation.......

import java.rmi.*;
import java.rmi.server.*;

public class name_imp extends UnicastRemoteObject implements name_int{

public name_imp() throws RemoteException {

  super(); 
}

public int add(int x,int y,int z){

  return x+y+z;
}

}

.......server..........

import java.rmi.*;

public class name_server{

 public static void main(String[] argv){
 
 try{
 
    name_int a = new name_imp();
    Naming.rebind("adder",a);
    System.out.println("Server connected");
 }
 
 catch(Exception e){
 System.out.println(e);
 }
 
 }

}
..........client.....

import java.rmi.*;

public class name_client{

public static void main(String[] argv){
 try{
    
    name_int a= (name_int)Naming.lookup("adder");
    System.out.println(a.add(5,5,5));
 }
 
 catch(Exception e){
    System.out.println(e);
 }
 
}
}
...........................................................................
>>>>>>>>user input 1 number>>>>>

.........interface.......

import java.rmi.*;

public interface nameInt extends Remote{
  
  public int add() throws RemoteException;
}

........impliment.....

import java.rmi.*;
import java.rmi.server.*;
import java.util.Scanner;

public class nameImp extends UnicastRemoteObject implements nameInt{

public nameImp() throws RemoteException{

super();

}

public int add() {
 
 Scanner s = new Scanner(System.in);
 System.out.println("Enter the number:");
 int x = s.nextInt();
 
 int b = x+x;
 
 return(b);
  
   
}
}

........server.........

import java.rmi.*;

public class nameSe{

  public static void main(String[] argv){
  
   try{
     
     nameInt a = new nameImp();
     Naming.rebind("adder",a);
     System.out.println("Server Connected");
     
   }
   
   catch(Exception e){
       System.out.println(e);
   }
   }
   }
   
   .......client.........
   
   import java.rmi.*;

public class nameclient{

 public static void main(String[] argv){
    
    try{
        
        nameInt a = (nameInt)Naming.lookup("adder");
        System.out.println(a.add());
    }
    catch(Exception e){
         System.out.println(e);
    }
    
 }
 }
 ................................................................

>>>>>>>>>>>calculate-no user input>>>>>>>>>>.

.......interface..........
import java.rmi.Remote;
import java.rmi.RemoteException;

public interface Calculator extends Remote {
    double add(double a, double b) throws RemoteException;
    double subtract(double a, double b) throws RemoteException;
    double multiply(double a, double b) throws RemoteException;
    double divide(double a, double b) throws RemoteException;
}


...........implement..............

import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class CalculatorImpl extends UnicastRemoteObject implements Calculator {

    protected CalculatorImpl() throws RemoteException {
        super();
    }

    @Override
    public double add(double a, double b) throws RemoteException {
        return a + b;
    }

    @Override
    public double subtract(double a, double b) throws RemoteException {
        return a - b;
    }

    @Override
    public double multiply(double a, double b) throws RemoteException {
        return a * b;
    }

    @Override
    public double divide(double a, double b) throws RemoteException {
        if (b == 0) {
            throw new ArithmeticException("Division by zero");
        }
        return a / b;
    }
}


...........server...............

import java.rmi.Naming;
import java.rmi.registry.LocateRegistry;

public class CalculatorServer {
    public static void main(String[] args) {
        try {
            LocateRegistry.createRegistry(1099); // Start RMI registry on port 1099
            CalculatorImpl calculator = new CalculatorImpl();
            Naming.rebind("rmi://localhost/CalculatorService", calculator);
            System.out.println("Calculator Service is running...");
        } catch (Exception e) {
            System.err.println("Server exception: " + e.toString());
            e.printStackTrace();
        }
    }
}


...........client..............

import java.rmi.Naming;

public class CalculatorClient {
    public static void main(String[] args) {
        try {
            Calculator calculator = (Calculator) Naming.lookup("rmi://localhost/CalculatorService");

            double a = 10.5, b = 5.2;
            System.out.println("Addition: " + calculator.add(a, b));
            System.out.println("Subtraction: " + calculator.subtract(a, b));
            System.out.println("Multiplication: " + calculator.multiply(a, b));
            System.out.println("Division: " + calculator.divide(a, b));

        } catch (Exception e) {
            System.err.println("Client exception: " + e.toString());
            e.printStackTrace();
        }
    }
}
.......................................................

>>>>>>>>>>>>>>calculator - user input>>>>>>>>>>>>>>>>


.........interface.................

import java.rmi.Remote;
import java.rmi.RemoteException;

public interface Calculator extends Remote {
    double add(double a, double b) throws RemoteException;
    double subtract(double a, double b) throws RemoteException;
    double multiply(double a, double b) throws RemoteException;
    double divide(double a, double b) throws RemoteException;
}

..........implentation............

import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class CalculatorImpl extends UnicastRemoteObject implements Calculator {

    protected CalculatorImpl() throws RemoteException {
        super();
    }

    @Override
    public double add(double a, double b) throws RemoteException {
        return a + b;
    }

    @Override
    public double subtract(double a, double b) throws RemoteException {
        return a - b;
    }

    @Override
    public double multiply(double a, double b) throws RemoteException {
        return a * b;
    }

    @Override
    public double divide(double a, double b) throws RemoteException {
        if (b == 0) {
            throw new ArithmeticException("Division by zero is not allowed.");
        }
        return a / b;
    }
}


..........server.............

import java.rmi.Naming;
import java.rmi.registry.LocateRegistry;

public class CalculatorServer {
    public static void main(String[] args) {
        try {
            LocateRegistry.createRegistry(1099); // Start RMI registry on port 1099
            CalculatorImpl calculator = new CalculatorImpl();
            Naming.rebind("rmi://localhost/CalculatorService", calculator);
            System.out.println("Calculator Service is running...");
        } catch (Exception e) {
            System.err.println("Server exception: " + e.toString());
            e.printStackTrace();
        }
    }
}


..............client.............

import java.rmi.Naming;
import java.util.Scanner;

public class CalculatorClient {
    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(System.in)) {
            // Look up the remote calculator service
            Calculator calculator = (Calculator) Naming.lookup("rmi://localhost/CalculatorService");

            System.out.println("Welcome to RMI Calculator!");
            boolean running = true;

            while (running) {
                System.out.println("\nSelect an operation:");
                System.out.println("1. Add");
                System.out.println("2. Subtract");
                System.out.println("3. Multiply");
                System.out.println("4. Divide");
                System.out.println("5. Exit");
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();

                if (choice == 5) {
                    System.out.println("Exiting Calculator. Goodbye!");
                    running = false;
                    continue;
                }

                System.out.print("Enter first number: ");
                double a = scanner.nextDouble();
                System.out.print("Enter second number: ");
                double b = scanner.nextDouble();

                double result = 0;
                try {
                    switch (choice) {
                        case 1:
                            result = calculator.add(a, b);
                            break;
                        case 2:
                            result = calculator.subtract(a, b);
                            break;
                        case 3:
                            result = calculator.multiply(a, b);
                            break;
                        case 4:
                            result = calculator.divide(a, b);
                            break;
                        default:
                            System.out.println("Invalid choice. Please try again.");
                            continue;
                    }
                    System.out.println("Result: " + result);
                } catch (Exception e) {
                    System.err.println("Error: " + e.getMessage());
                }
            }
        } catch (Exception e) {
            System.err.println("Client exception: " + e.toString());
            e.printStackTrace();
        }
    }
}



...................................................................

>>>>>>>>>>>>>>MPI>>>>>>>>>>>>>>>>>>>

...........ping-pong.................

#include <mpi.h>
#include <stdio.h>

int main(int argc, char** argv) {

    // Initialize MPI 
    MPI_Init(NULL,NULL);

    // Get the number of processes
    int world_size;
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);

    // Get the rank of the process
    int world_rank;
    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);

    // Ensure at least two processes are running
    if (world_size < 2) {
        if (world_rank == 0) {
            printf("Number of processes must be at least 2\n");
        }
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    // Ping-Pong Logic
    const int PING_PONG_LIMIT = 15;
    int ping_pong_count = 0;
    int partner_rank = (world_rank + 1) % 2; // (0+1)%2 = 1 or (1+1)%2 = 0

    while (ping_pong_count < PING_PONG_LIMIT) {
        if (world_rank == ping_pong_count % 2) {
            
            ping_pong_count++;
            MPI_Send(&ping_pong_count, 1, MPI_INT, partner_rank, 0, MPI_COMM_WORLD);

           
        } else {
            
            MPI_Recv(&ping_pong_count, 1, MPI_INT, partner_rank, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            printf("Process %d received count %d from process %d\n", world_rank, ping_pong_count, partner_rank);
        }
    }


    // Finalize MPI
    MPI_Finalize();
}

.............add two number MPI...........

#include <mpi.h>
#include <stdio.h>

int main(int argc, char** argv) {
int num1;
int num2;

//Initialize MPI
    MPI_Init(NULL, NULL);

//Get the number of processors

    int world_size;
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);

//Get the number of ranks

    int world_rank;
    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);

//Get the name of the processor

    char processor_name[MPI_MAX_PROCESSOR_NAME];
    int name_len;
    MPI_Get_processor_name(processor_name, &name_len);


//send message from the master
if(world_rank == 0 ){
num1 = 10;
num2 = 20;
MPI_Send(&num1,1,MPI_INT,1,0,MPI_COMM_WORLD);
MPI_Send(&num2,1,MPI_INT,1,0,MPI_COMM_WORLD);
}
//receive message from the master
if(world_rank > 2 ){

MPI_Recv(&num1,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
MPI_Recv(&num2,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
}

int result = num1 + num2;

    printf("Process %d : The sum of %d and %d is %d\n",world_rank, num1,num2,result);

//Finalize MPI

    MPI_Finalize();
    
}
...................................................................
>>>>>>>>>>>>>fortran>>>>>>>>>>>

...............mark avarage---------

PROGRAM CalculateAverage
  IMPLICIT NONE

  INTEGER :: i, n
  REAL :: total, average
  REAL, ALLOCATABLE :: marks(:)

  ! Read the number of marks to process
  PRINT *, 'Enter the number of marks:'
  READ *, n

  ! Allocate memory for the marks array
  ALLOCATE(marks(n))

  ! Initialize total to 0
  total = 0.0

  ! Read the marks
  PRINT *, 'Enter the marks:'
  DO i = 1, n
     READ *, marks(i)
     total = total + marks(i)
  END DO

  ! Calculate the average
  average = total / n

  ! Write the result
  PRINT *, 'The average mark is:', average

  ! Deallocate the array
  DEALLOCATE(marks)

END PROGRAM CalculateAverage


...........with MPI AND Fortran..........

program mpi_hello_world
 use mpi
implicit none
 integer :: rank, size, ierr, tag
 integer :: source, dest
 character(len=20) :: message
 integer :: status(MPI_STATUS_SIZE)
 tag = 0 ! Tag for the message
 source = 0 ! Process rank 0 will send the message
 dest = 1 ! Process rank 1 will receive the message
 call MPI_INIT(ierr) ! Initialize MPI
 call MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierr) ! Get
process rank
 call MPI_COMM_SIZE(MPI_COMM_WORLD, size, ierr) ! Get
total number of processes
 if (size < 2) then
 if (rank == 0) then
 print *, "This program requires at least 2 processes!"
 end if
 call MPI_FINALIZE(ierr)
 stop
 end if
 if (rank == source) then
 message = "Hello, World!" ! Message to send
 call MPI_SEND(message, len(message), MPI_CHARACTER,
dest, tag, MPI_COMM_WORLD, ierr)
 print '(A,I3,A,A,A,I3)', "Process", rank, "sent message:",
trim(message), "to process", dest
 else if (rank == dest) then
 call MPI_RECV(message, len(message), MPI_CHARACTER,
source, tag, MPI_COMM_WORLD, status, ierr)
 print '(A,I3,A,A,A,I3)', "Process", rank, "received message:",
trim(message), "from process", source
 end if
 call MPI_FINALIZE(ierr) ! Finalize MPI
end program mpi_hello_world


...............add two number MPI & fortran......................

program mpi_add_numbers
 use mpi
 implicit none
 integer :: rank, size, ierr, tag
 integer :: source, dest
 integer :: num1, num2, sum
 integer :: status(MPI_STATUS_SIZE)
 tag = 0
 source = 0
 dest = 1
 call MPI_INIT(ierr) ! Initialize MPI
 call MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierr)
 call MPI_COMM_SIZE(MPI_COMM_WORLD, size, ierr)
 if (size < 2) then
 if (rank == 0) then
 print *, "This program requires at least 2 processes!"
 end if
 call MPI_FINALIZE(ierr)
 stop
 end if
 if (rank == source) then
 num1 = 5
 num2 = 10
 call MPI_SEND(num1, 1, MPI_INTEGER, dest, tag, MPI_COMM_WORLD, ierr)
 call MPI_SEND(num2, 1, MPI_INTEGER, dest, tag, MPI_COMM_WORLD, ierr)
 print '(A,I3,A,I0)', "Process", rank, "sent numbers:", num1, "and", num2, "to process", dest
 else if (rank == dest) then
 call MPI_RECV(num1, 1, MPI_INTEGER, source, tag, MPI_COMM_WORLD, status, ierr)
 call MPI_RECV(num2, 1, MPI_INTEGER, source, tag, MPI_COMM_WORLD, status, ierr)
 sum = num1 + num2
 print '(A,I3,A,I0,A,I0)', "Process", rank, "received numbers:", num1, "and", num2, "with sum:", sum
 end if
 call MPI_FINALIZE(ierr)
end program mpi_add_numbers

..............................................

gfortran -o name namee.f90
./name

........................................

mpicc -c name name.c
mpirun -np 2 ./name

..........................

javac name.java
rmic nameimpl
javac nameclient
rmiregistry &
java server
java client

................................................................................


#include<mpi.h>
#include<stdio.h>

int main(int argc,char ** argv){

	MPI_Init(NULL,NULL);
	int number = 42;

	int world_size;
	MPI_Comm_size(MPI_COMM_WORLD,&world_size);

	int world_rank;
	MPI_Comm_rank(MPI_COMM_WORLD,&world_rank);

	if(world_size<2){
		if(world_rank == 0){
			printf("Error\n");
		}

		MPI_Abort(MPI_COMM_WORLD,1);
	}

	if(world_rank == 0){
	
		MPI_Send(&number,1,MPI_INT,1,0,MPI_COMM_WORLD);
		printf("Rank 0 send data %d to Rank 1\n",number);
	}
	else if(world_rank == 1){
		int recvdata;
		MPI_Recv(&recvdata,1,MPI_INT,0,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);

		printf("Received Rank 0 data %d into Rank 1\n ",recvdata);
	}

	MPI_Finalize();
}

................................................................


#include<mpi.h>
#include<stdio.h>

int main(int argc,char ** argv){

	MPI_Init(NULL,NULL);
	int number = 42;

	int world_size;
	MPI_Comm_size(MPI_COMM_WORLD,&world_size);

	int world_rank;
	MPI_Comm_rank(MPI_COMM_WORLD,&world_rank);

	if(world_size<2){
		if(world_rank == 0){
			printf("Error\n");
		}

		MPI_Abort(MPI_COMM_WORLD,1);
	}
	//ping pong logic

	int p_count =0;
	int p_limit =10;
	int partner_rank = (world_rank == 0)? 1:0;

	while(p_count <p_limit){
		if(world_rank == p_count%2){
			p_count++;

			MPI_Send(&p_count,1,MPI_INT,partner_rank,0,MPI_COMM_WORLD);
			printf("Rank %d sent ping pong count %d to Rank %d\n",world_rank,p_count,partner_rank);

		}else
		{
			MPI_Recv(&p_count,1,MPI_INT,partner_rank,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
			printf("Rank %d received ping pong count %d from Rank %d\n",world_rank,p_count,partner_rank);
		}
	}

	

	MPI_Finalize();
}

..........................................................

#include <mpi.h>
#include <stdio.h>

int main(int argc, char** argv) {
    MPI_Init(NULL, NULL);

    int world_size, world_rank;
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);
    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);

    if (world_size < 2) {
        if (world_rank == 0) {
            printf("Error: This program requires at least 2 processes.\n");
        }
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    // Ping-pong logic
    int p_count = 0;
    int p_limit = 10;
    int partner_rank = (world_rank + 1) % world_size;

    while (p_count < p_limit) {
        if (world_rank == p_count % world_size) {
            // Increment and send the ping-pong count
            p_count++;
            MPI_Send(&p_count, 1, MPI_INT, partner_rank, 0, MPI_COMM_WORLD);
            printf("Rank %d sent ping pong count %d to Rank %d\n", world_rank, p_count, partner_rank);
        } else {
            // Receive the ping-pong count
            MPI_Recv(&p_count, 1, MPI_INT, (world_rank - 1 + world_size) % world_size, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            printf("Rank %d received ping pong count %d from Rank %d\n", world_rank, p_count, (world_rank - 1 + world_size) % world_size);
        }
    }

    MPI_Finalize();
    return 0;
}


..................................................................

#include <mpi.h>
#include <stdio.h>

int main(int argc, char** argv) {
    MPI_Init(NULL, NULL);

    int world_size, world_rank;
    MPI_Comm_size(MPI_COMM_WORLD, &world_size);
    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);

    if (world_size < 2) {
        if (world_rank == 0) {
            printf("Error: This program requires at least 2 processes.\n");
        }
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    // Set ping pong limit
    int p_count = 0;
    int p_limit = 5; // Modify this value to observe different limits
    int partner_rank = (world_rank + 1) % world_size;

    while (p_count < p_limit) {
        if (world_rank == p_count % world_size) {
            // Increment and send the ping pong count
            p_count++;
            MPI_Send(&p_count, 1, MPI_INT, partner_rank, 0, MPI_COMM_WORLD);
            printf("Rank %d sent ping pong count %d to Rank %d\n", world_rank, p_count, partner_rank);
        } else {
            // Receive the ping pong count
            MPI_Recv(&p_count, 1, MPI_INT, (world_rank - 1 + world_size) % world_size, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            printf("Rank %d received ping pong count %d from Rank %d\n", world_rank, p_count, (world_rank - 1 + world_size) % world_size);
        }
    }

    MPI_Finalize();
    return 0;
}
.....................................................
